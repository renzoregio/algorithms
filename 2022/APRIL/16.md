## ALGORITHM

#### SOLVED IN JAVASCRIPT
### QUESTION

#### [897. Increasing Order Search Tree](https://leetcode.com/problems/increasing-order-search-tree/)

Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.

Example 1:

![Example 1](https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg)

```
Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
```

Example 2:

![Example 2](https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg)

```
Input: root = [5,1,7]
Output: [1,null,5,null,7]
```


Constraints:

* The number of nodes in the given tree will be in the range [1, 100].
* 0 <= Node.val <= 1000

-----

### JavaScript

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var increasingBST = function(root) {
    const arr = []
    
    const dfs = (node) => {
        if(!node)
            return
        
        arr.push(node.val)
        
        if(!node.left && !node.right)
            return 
        
        dfs(node.left)
        dfs(node.right)
    } 
    
    dfs(root)
    arr.sort((a, b) => a - b)
    let nodeCount = 1;
    let rootNode = new TreeNode()
    rootNode.val = arr[0];
    let node = rootNode;
    
    while(nodeCount < arr.length){
        node.right = new TreeNode();
        node = node.right;
        node.val = arr[nodeCount]
        nodeCount++
    }
    
    return rootNode
    
};

```
